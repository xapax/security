<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="xapax">
    
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Deserialization Attacks - Notes</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Java deserialization attacks", url: "#_top", children: [
              {title: "Identify", url: "#identify" },
              {title: "Exploit", url: "#exploit" },
          ]},
          {title: "PHP deserialization attacks", url: "#php-deserialization-attacks", children: [
              {title: "Magic methods", url: "#magic-methods" },
              {title: "Exploit", url: "#exploit_1" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../dom_based_xss/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../dom_based_xss/" class="btn btn-xs btn-link">
        DOM XSS
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../cross_site_web_socket_hijack/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../cross_site_web_socket_hijack/" class="btn btn-xs btn-link">
        Cross-Site Web Socket Hijack (CSHSH)
      </a>
    </div>
    
  </div>

    

    <p>Serialization (aka marshaling) = process of converting programming object to string.</p>
<p>Deserialization (aka marshaling) = process of converting string to programming object</p>
<p>Serialization is supported is many programming languages, like Java, Python, Ruby, Php.</p>
<p>Burp Suite is looking for deserialized objects in its passive scan (you can see this if you go to scanning ooptions and look for "serialized objects in HTTP message". Exactly how it does this is unclear. I have seen it identify a PHP serialized object.</p>
<p>Serialization is often times done in order to be able to send the object, over the network, for example. Or so that it can be stored.
Both JSON and XML are example of serialized data.</p>
<h2 id="java-deserialization-attacks">Java deserialization attacks<a class="headerlink" href="#java-deserialization-attacks" title="Permanent link">#</a></h2>
<p>Anything can be serialized, it doesn't have to be an object. It can be a string, boolean, function, etc.
The difficuly of exploiting deserialization bugs is that you can never introduce code. You will only be able to control the properties of already existing objects. That is why it is called POP-gadget, property-oriented-programming.
This difficuly is in part overcome due to the fact that many applications load in libraries where useful classes exist. That is what ysoserial does. It just creates payloads that can be used if a specific library exists, and then you just test all of them. It is kind of a shot gun approach.</p>
<p>So, unles you have access to the source code your best bet is probably to just use the shotgun approach and send in all ysoserial payloads, and hope that the application has included one of ysoserial third-party libraries.
However, it should be noted that testing all payloads might lead to an unhandled exception and the application might crash. So there is always that risk involved.</p>
<p>The ysoserial payloads are blind payloads, and not command output is returned. </p>
<h3 id="identify">Identify<a class="headerlink" href="#identify" title="Permanent link">#</a></h3>
<h4 id="with-the-source-code-white-box">WIth the source code / white-box<a class="headerlink" href="#with-the-source-code-white-box" title="Permanent link">#</a></h4>
<p>In source code:</p>
<p>You can check the source code to find out if a vulnerable library is being used.</p>
<p>The functions to serialize or unserialize in Java is</p>
<p>Here is an example, where we serialize the string "name", and write the output to a file called file.bin.
The function that actually serialize the object is <code>out.writeObject(name)</code></p>
<pre><code class="Java">import java.io.*;

public class Serial
{
    public static void main(String[] args)
    {
        String name = &quot;Nytro&quot;;
        String filename = &quot;file.bin&quot;;

        try
        {
            FileOutputStream file  = new FileOutputStream(filename);
            ObjectOutputStream out = new ObjectOutputStream(file);

            // Serialization of the &quot;name&quot; (String) object
            // Will be written to &quot;file.bin&quot;

            out.writeObject(name); //Here is the serialization. The serialized object is written to the file file.bin

            out.close();
            file.close();
        }
        catch(Exception e)
        {
            System.out.println(&quot;Exception: &quot; + e.toString());
        }
    }
}

</code></pre>

<p>The result of the code is that the object is written to a file, if we look at the content of that file it shows us the following:</p>
<pre><code>AC ED 00 05 74 00 05 4e 79 74 72 6f            ....t..Nytro
</code></pre>

<p>This is just like a a PHP serilaized object, but the "syntaxt" to read it is a bit more difficult, because it is binary and not only ASCII as in PHP.</p>
<p>Data starts with the binary "AC ED" - this is the "magic number" that identifies serialized data, so all serialized data will start with this value
Serialization protocol version "00 05"
We only have a String identified by "74"
Followed by the length of the string "00 05"
And, finally, our string</p>
<p>For more documentation on the protocol on serialized objects see: https://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html</p>
<p>So, how to we deserialize it again?</p>
<p>Just as <code>writeObject()</code> serializes an object <code>readObject()</code> deserializes the object.</p>
<pre><code>String name;
String filename = &quot;file.bin&quot;;

try
{
    FileInputStream file  = new FileInputStream(filename);
    ObjectInputStream out = new ObjectInputStream(file);

    // Serialization of the &quot;name&quot; (String) object
    // Will be written to &quot;file.bin&quot;

    name = (String)out.readObject();
    System.out.println(name);

    out.close();
    file.close();
}
catch(Exception e)
{
    System.out.println(&quot;Exception: &quot; + e.toString());
}
</code></pre>

<p>It is not only <code>readObject()</code> that is vulnerable. The following methods are some that also deserializes an object:</p>
<pre><code>readResolve
readExternal
readUnshared
XStream
</code></pre>

<p>So, in order to identify deserialization vulnerabilities we need to identify an entry point, and code snippets/objects that we can manipulate the properties of.</p>
<h5 id="entry-point">Entry point<a class="headerlink" href="#entry-point" title="Permanent link">#</a></h5>
<p>We can look for the usage of the following class:</p>
<pre><code>java.io.ObjectInputStream
</code></pre>

<p>Or for classes that are serializeable and implekentn the readObject class.</p>
<p>Serialized java objects always begin with <code>ac ed</code> in hex, and <code>r00</code> in base64 objects.</p>
<h4 id="without-source-code-black-box">Without source code / black box<a class="headerlink" href="#without-source-code-black-box" title="Permanent link">#</a></h4>
<p><code>ac ed</code> is the "magic number" for deserialized objects.
Check the POST body or other areas for the base64 string <code>r00AB</code>.
If it is not base64 encoded, it will looke like something with non-printable characters, and it might include stuff like <code>/java/lang/string</code> and things like that.</p>
<p>It might look something like this:</p>
<pre><code>¬í..sr..LogFile×

</code></pre>

<p>You can also look for the following content-type: <code>application/x-java-serialized-object</code></p>
<p>https://blog.netspi.com/java-deserialization-attacks-burp/</p>
<p>Example of vulnerable servers:
WEbLogic
WebSphere
Jboss
I JBoss 6.1.0 applikationer så är det sårbara URL:en <code>/invoker/JMKInvokerServlet</code>.
Jenkins
Soffid IAM</p>
<p>Serialized java objects can be found in HTTP Request parameters, view state or cookies. </p>
<h3 id="exploit">Exploit<a class="headerlink" href="#exploit" title="Permanent link">#</a></h3>
<p>Okay, so you have identified where the application is receiving serialized java objects. As i mentioned before, you will only be able to exploit it if the application is compiled with classes that can cause harm. How will you know that if you are black-box testing? Well, you don't. So you just test every single payload possible.
Luckily there are common libraries that have vulnerable classes that are known, so if the target application is compiles with those libraries it is possible to exploit.</p>
<p>A common way to produce the exploits is by using the tool ysoserial. It can be found here:</p>
<p>https://github.com/frohoff/ysoserial
If you want to compile it yourself you just need to download the source-code.</p>
<pre><code>apt install maven
apt  install openjdk-8-jdk
mvn clean package -DskipTests
</code></pre>

<p>Otherwise you can just download the jar-file and hope that it is not tampered with.
You generate your payload like this:</p>
<pre><code>java -jar ysoserial-0.0.5-all.jar Groovy1 &quot;touch /tmp/poooooowdn&quot; &gt; payload.txt
</code></pre>

<p>You have to check the help section to see what payloads are avaiable.
There is a also a burp plugin that will generate and test the payloads.</p>
<p>Anyways, I just wanted to explain a little bit about how these payloads actually work.</p>
<p>So, the only thing an attacker can control is which object to send, and the properties of that object.</p>
<h1 id="php-deserialization-attacks">PHP deserialization attacks<a class="headerlink" href="#php-deserialization-attacks" title="Permanent link">#</a></h1>
<p>In order to turn an object into a string in PHP you can use</p>
<pre><code>serialize()
</code></pre>

<p>This can be exmplified like this</p>
<pre><code class="php">&lt;?php
$the_array = array(&quot;lorem&quot;, &quot;ipsum&quot;, &quot;Dolor&quot;);
$serialized = serialize($the_array);
print $serialized;
?&gt;
</code></pre>

<pre><code>// the following will be printed:
a:3:{i:0;s:5:&quot;lorem&quot;;i:1;s:5:&quot;ipsum&quot;;i:2;s:5:&quot;Dolor&quot;}
</code></pre>

<p>It is pretty simply to decode:
array containing 3 elements <code>a:3</code>
index 0, string with five characters, which are lorem <code>i:0;s:5:lorem</code>
etc.</p>
<p>Unserialize does the same thing, but the other way around. It takes serialized strings and turn them into objects.</p>
<pre><code class="php">$theobject = unserialize('&quot;a:3:{i:0;s:5:&quot;lorem&quot;;i:1;s:5:&quot;ipsum&quot;;i:2;s:5:&quot;Dolor&quot;}');
</code></pre>

<h2 id="magic-methods">Magic methods<a class="headerlink" href="#magic-methods" title="Permanent link">#</a></h2>
<p>Okay, but let's say that we can send in a serialized object to have it unserialized. What can that even do? How can the code be executed?</p>
<p>Enter PHP autoloading.
PHP objects/classes can have methods that are automatically executed when the class is initialized.
These automatic functions are sometimes called magic method.
THe following are examples of some magic methods.
Remember that there is not guarantee that a class has these magic methods. But if the class do have it they will automatically execute.</p>
<p>So if the class has any of these methods they will be run when the class is initilized, for example by doing:</p>
<pre><code class="php">&lt;?php
$newinst = new LoggerClass();

//Or when deserializing an object

$serializedObj = serialize($newinst);

unserialize($serialized)

</code></pre>

<pre><code>__construct()
__destruct()
__call()
__callStatic()
__get()
__set()
__isset()
__unset()
__sleep()
__wakeup()
__toString()
__invoke()
__set_state()
__clone()
__autoload().
</code></pre>

<p>The most common methods are <code>__construct</code>, <code>__destruct</code>, <code>__wakeup</code>
However, there are many more. </p>
<p>When you run <code>unserialize()</code> the object is instatiated. It is the same as running <code>new class()</code>.</p>
<p>So, in orderto exploit the vulnerability, we need the following requirements:</p>
<ol>
<li>The application must recieve a serialized object somewhere from the user. From a GET or POST parameter for example, or in a Cookie.</li>
<li>The PHP file where the unserialize-function is executed must contain a useful class, or import a class that is useful.</li>
<li>The useful class must contain a magic function that perform the useful action, such as writing to disk.</li>
</ol>
<p>A common magic method is destruct. It is run when the obejct is terminated. A common usage for it, is to be used to store cache files on disk, or stuff like that. Or perform shutdown queries to a database for example.</p>
<pre><code>__destruct()
</code></pre>

<h2 id="exploit_1">Exploit<a class="headerlink" href="#exploit_1" title="Permanent link">#</a></h2>
<p>Exploiting PHP serialization attacks is quite difficult if you don't have access to the source code, because you don't know what classes are available.</p>
<p>In order to exploit a PHP deserialization attack the following requirements are necessary:</p>
<ul>
<li>The application must unserialize data that can be controlled by the attacker.</li>
<li>The application must have a class which implements the PHP magic methods <code>__wakeup</code> or <code>__destruct</code>. Or any other magic method.</li>
<li>The class with the magic method needs to be included in the file where the unserialize is happening.</li>
<li>The class must do something that can be of interest to the attacker, such as writing to disk, so you can upload a shell.</li>
</ul>
<h4 id="step-1-find-unserialize">Step 1 - find unserialize<a class="headerlink" href="#step-1-find-unserialize" title="Permanent link">#</a></h4>
<p>Burp will look for strings that might be serialized. So check your passive scanner in burp, it says something like "Serialized object in HTTP message".</p>
<p>Check for strings that look like this:</p>
<pre><code>s:1:”s”;s:13:”Hi  this test  “;
</code></pre>

<p>However, it is more likely that the serialized object is actually base64-encoded, so decode all base64-encoded data you find.</p>
<p>With source-code:
If you check the source-code looks for:</p>
<pre><code>unserialize()
</code></pre>

<p>If you see that function in the source-code, look to see if user-controlled data is sent to the <code>unserialize()</code> function.</p>
<p>Just search all the source files for <code>unserialize</code>, in wordpress it may also be called <code>maybe_unserialize</code>.</p>
<p>Now, you also need to find out if the input parameter to unserialize can be controlled by the attacker. Find out where it comes from.</p>
<h4 id="step-2-find-a-class-to-abuse">Step 2 - Find a class to abuse<a class="headerlink" href="#step-2-find-a-class-to-abuse" title="Permanent link">#</a></h4>
<p>Okay, so you have found a point where attacker-controlled data is sent to <code>unserialize()</code>. Now we need to find a class that is:
- A. Contains a magic function.
- B. Performs an action that is desirable to the attacker (such as writing to disk)
- C. Available to use
- D. Build payload</p>
<p>So in what end do we start?
We can start in different ends, either by searching the source-code for magic functions, or search the source-code for useful functions and hope that they are executed from a magic function.</p>
<p><strong>A. Contains a magic function</strong></p>
<p>Maybe start looking through the source-code for functions like:</p>
<pre><code>__construct
__destruct
__wakeup
</code></pre>

<p><strong>B. Performs an action that is desirable to the attacker</strong></p>
<p>When you have identified a class containing a magic function you need to see if the magic function performs an action that is desirable to the attacker.
Remember that the attacker can controll all properties in the class.
A common function to be abused is for a class to write error messages to log files. 
The <code>file_put_contents</code>-function could be in another function that is called from <code>__destruct</code>. An example of such a class would be the following:</p>
<pre><code class="php">&lt;?php
class Logger(){
    $stringLogfile;
    $stringLogtext;

    public function __destruct()
    {
        file_put_contents($stringLogfile, $stringLogtext, FILE_APPEND);
    }
}
?&gt;
</code></pre>

<p>Remember that what is a desirable function may vary, of course it would be great to write to files or execute commands. But it could be any other type of action, such as deleting a file, or writing to a database. Or making a request somewhere.</p>
<p>But here are some well known desirable functions to search for:</p>
<pre><code>File Access:
file_put_contents()
file_get_contents()
unlink()

Command execution:
exec()
passthru()
popen()
system()

</code></pre>

<p><strong>C. Available to use</strong>
Now we have identified a class which contains a Magic function that performs an action that is desirable to us, now we only need to make sure that is is available to us.
This will require you to go from the source-file where the unserialize-function is executed backwards to see if the usable class is included. Remember that classes are included recursivly. So if your source-file your have:</p>
<pre><code class="php">&lt;?php
//My vulnerable class
include_once(&quot;someotherclass.php&quot;)


unserialize($COOKIE-&gt;&quot;USER&quot;)
?&gt;
</code></pre>

<p>You need to check out <code>someotherclass.php</code></p>
<pre><code class="php">&lt;?php
//someotherclass.php

require(&quot;moreclasses.php&quot;)
include_once(&quot;evenmoreclasses.php&quot;)
?&gt;
</code></pre>

<pre><code class="php">&lt;?php
//moreclasses.php
?&gt;
</code></pre>

<p>If you don't feel like doing this type of analysis, you can just hope that all files are included, something which is not uncommon, and just run your exploit and hope for the best.</p>
<p><strong>D. Build payload</strong></p>
<p>It is a tedious work to actaully build the serialized string by hand. So a better way is to have PHP do it. Just copy the entire class, edit the properties that you need to use, serialize it and then base64-encode it, if that is required. If you get errors when you serialize the class it might be because the code is referencing other classes, you can sometimes fix this simply by removing that code.</p>
<p>Here is an example of a class, and how to produce a serialized object of it.
REMEBER to URL encode the payload before you send it, or base64-encode it if that is required:</p>
<pre><code class="php">// testfil.php
&lt;?php
class JustTesting {
    var $file = &quot;/path/to/file.php&quot;;
    public function __destruct(){
        echo file_get_contents($this-&gt;file, TRUE);
    }
}

$newTest = new JustTesting();

echo serialize($newTest);
?&gt;
</code></pre>

<pre><code class="bash">apt install php-cli

php -f testfil.php
</code></pre>

<p>Now you just copy the payload and send it in.</p>
<h4 id="blackbox">Blackbox<a class="headerlink" href="#blackbox" title="Permanent link">#</a></h4>
<p>So, as an attacker you can't know what classes are included, what classes are available to you.
However, if the application is built using framework. Such as composer, composer will include all all composer libraries. So you might find a class from any of those libraries.</p>
<p>See this: https://insomniasec.com/downloads/publications/Practical%20PHP%20Object%20Injection.pdf</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../dom_based_xss/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../dom_based_xss/" class="btn btn-xs btn-link">
        DOM XSS
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../cross_site_web_socket_hijack/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../cross_site_web_socket_hijack/" class="btn btn-xs btn-link">
        Cross-Site Web Socket Hijack (CSHSH)
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://github.com/xapax/edit/master/docs/attacking_web_applications/deserialization_attacks.md"><i class="fa fa-github"></i>
Edit on GitHub</a>
      </p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>